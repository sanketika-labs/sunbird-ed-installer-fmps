apiVersion: v1
data:
  common.rego: |-
    package common

    import input.attributes.request.http as http_request
    import future.keywords.in

    ROLES := {
       "BOOK_REVIEWER": ["createLock", "publishContent", "listLock", "retireLock", "refreshLock", "rejectContent", "rejectContentV2"],

       "CONTENT_REVIEWER": ["createLock", "publishContent", "listLock", "retireLock", "refreshLock", "rejectContent", "rejectContentV2"],

       "FLAG_REVIEWER": ["publishContent", "rejectContent", "rejectContentV2"],

       "BOOK_CREATOR": ["copyContent", "createContent", "createLock", "updateCollaborators", "collectionImport", "collectionExport", "submitContentForReviewV1", "submitContentForReviewV3", "createAsset", "uploadAsset", "updateAsset", "uploadUrlAsset", "copyAsset", "listLock", "retireLock", "refreshLock", "updateContent", "uploadContent"],

       "CONTENT_CREATOR": ["updateBatch", "copyContent", "createContent", "createLock", "updateCollaborators", "collectionImport", "collectionExport", "submitContentForReviewV1", "submitContentForReviewV3", "submitDataExhaustRequest", "getDataExhaustRequest", "listDataExhaustRequest", "createAsset", "uploadAsset", "updateAsset", "uploadUrlAsset", "copyAsset", "listLock", "retireLock", "refreshLock", "updateContent", "uploadContent", "courseBatchAddCertificateTemplate", "courseBatchRemoveCertificateTemplate", "createBatch"],

       "COURSE_CREATOR": ["updateBatch", "copyContent", "createContent", "createLock", "updateCollaborators", "collectionImport", "collectionExport", "submitContentForReviewV1", "submitContentForReviewV3", "createAsset", "uploadAsset", "updateAsset", "uploadUrlAsset", "copyAsset", "listLock", "retireLock", "refreshLock",  "updateContent", "uploadContent", "courseBatchAddCertificateTemplate", "courseBatchRemoveCertificateTemplate", "createBatch"],

       "COURSE_MENTOR": ["updateBatch", "submitDataExhaustRequest", "getDataExhaustRequest", "listDataExhaustRequest", "courseBatchAddCertificateTemplate", "courseBatchRemoveCertificateTemplate", "createBatch"],

       "PROGRAM_MANAGER": ["submitDataExhaustRequest", "getDataExhaustRequest", "listDataExhaustRequest"],

       "PROGRAM_DESIGNER": ["submitDataExhaustRequest", "getDataExhaustRequest", "listDataExhaustRequest"],

       "ORG_ADMIN": ["acceptTnc", "assignRole", "submitDataExhaustRequest", "getDataExhaustRequest", "listDataExhaustRequest", "getUserProfileV5", "updateUserV2", "readUserConsent", "createTenantPreferences", "updateTenantPreferences", "createReport", "deleteReport", "updateReport", "publishReport", "retireReport", "getReportSummary", "listReportSummary", "createReportSummary"],

       "REPORT_VIEWER": ["acceptTnc", "getReportSummary", "listReportSummary"],

       "REPORT_ADMIN": ["submitDataExhaustRequest", "getDataExhaustRequest", "listDataExhaustRequest", "acceptTnc", "createReport", "deleteReport", "updateReport", "publishReport", "retireReport", "getReportSummary", "listReportSummary", "createReportSummary"],

       "PUBLIC": ["PUBLIC"]
    }

    x_authenticated_user_token := http_request.headers["x-authenticated-user-token"]
    x_authenticated_for := http_request.headers["x-authenticated-for"]
    private_ingressgateway_ip := "10.0.0.10"

    jwt_public_keys := {
    "access_v1_key1": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7c1Fx8ZmHQNz+bqdmZrl\nPtFHex36uOoL62JHxbm/szSTzMdnX9VIZVGtvgqmwPSSLP8Zu2Pe+T5wU/PtGyyC\nwCbM9JBLc4bBHHPyNuVyXFxV6aZ3Csw5mTGa7PrWcJBdmnkovoq+lMTfej0B8xmS\n51v/OuB3hbnQanHDzpLqeUjQlqljiurBW/IDwaMeflUf82omQOz/IbM6tFVn8JJt\nNR5N+BMTt1c5E/ZCiijn8kOrMZLdnpk0NoZDQIO5EzkNb7h119gvGyZmuvX3aG6G\nn4M+9z+iBKDUSZfAKhxIvdJ2qkdJcZFFH6sD39LPqMLtIeI6hgXiJtytSZ79dj4k\neQIDAQAB\n-----END PUBLIC KEY-----",
    "access_v1_key2": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlMH3FYfpYkM6Kf+tdoNW\nqBKSawTKqXzKkjhwqzgiysmaaQXnnkbl+EuFGyPymrApbY0KIxVn1Si+kpGr6kJX\ns0mBgSFlVWGsM00QP8qrNn0j3+Qf+GcnYTKNqZo/4ueN4lcqIu+T2e9JvWdxykUZ\ng+UTYS1+6zk9QECTaXTD7I74xyeq6pkE5x8vqWABXskDKHk1QtcuauNOxR4qTZPK\nsUpKYYaAyHAsBQG44/WOn5Zta9npNrnQdb9zZT2+TS/xph3EJrrA/BtWyDyE88eU\nQu0aEFOeXi1myTyfjl3Bovzs5A/olDlpXJf9OmtSR2oTRjNsds6sctVG4Crs9Xoy\nEwIDAQAB\n-----END PUBLIC KEY-----",
    "KEYCLOAK_KID": "KEYCLOAK_PUBLIC_KEY"
    }

    user_token := {"header": header, "payload": payload} {
      encoded := x_authenticated_user_token
      [header, payload, _] := io.jwt.decode(encoded)
    }

    for_token := {"payload": payload} {
      encoded := x_authenticated_for
      [_, payload, _] := io.jwt.decode(encoded)
    }

    iss := "https://maharat.fmps.ma/auth/realms/sunbird"
    token_kid := user_token.header.kid
    token_iss := user_token.payload.iss
    token_exp := user_token.payload.exp
    current_time := time.now_ns()

    token_sub := split(user_token.payload.sub, ":")
    # Check for both cases - With and without federation_id in sub field as below
    # sub := f:federation_id:user_id OR sub := user_id
    token_userid = token_sub[2] {
        count(token_sub) == 3
    } else = token_sub[0] {
        count(token_sub) == 1
    }
    for_token_userid := for_token.payload.sub
    for_token_parentid := for_token.payload.parentId

    # Desktop app is still using keycloak tokens which will not have roles
    # This is a temporary fix where we will append the roles as PUBLIC in OPA

    default_role := [{"role": "PUBLIC", "scope": []}]

    token_roles = user_token.payload.roles {
        user_token.payload.roles
    } else = default_role {
        not user_token.payload.roles
    }

    for_token_exists {
      x_authenticated_for
      count(x_authenticated_for) > 0
    }

    userid = token_userid {
        not x_authenticated_for
    } else = token_userid {
        count(x_authenticated_for) == 0 # This is a temporary fix as the mobile app is sending empty headers as x-authenticated-for: ""
    } else = for_token_userid {
        for_token_exists
    }

    validate_token {
      io.jwt.verify_rs256(x_authenticated_user_token, jwt_public_keys[token_kid])
      token_exp * 1000000000 > current_time
      token_iss == iss
    }

    is_an_internal_request {
      http_request.host == private_ingressgateway_ip
    }

    acls_check(acls) = indicies {
      validate_token
      indicies := [idx | some i; ROLES[token_roles[i].role][_] == acls[_]; idx := i]
      count(indicies) > 0
    }

    role_check(roles) = indicies {
      indicies := [idx | some i; token_roles[i].role in roles; idx := i]
      count(indicies) > 0
    }

    org_check(roles) = token_organisationids {
      indicies :=  role_check(roles)
      count(indicies) > 0
      token_organisationids := [ids | ids := token_roles[indicies[_]].scope[_].organisationId]
      count(token_organisationids) > 0
    }

    parent_id_check {
        x_authenticated_for
        count(x_authenticated_for) > 0
        token_userid == for_token_parentid
    }

    parent_id_check {
        count(x_authenticated_for) == 0
    }

    parent_id_check {
        not x_authenticated_for
    }

    public_role_check {
      acls := ["PUBLIC"]
      roles := ["PUBLIC"]
      acls_check(acls)
      role_check(roles)
      userid
      parent_id_check
    }
  main.rego: |-
    package main

    import input.attributes.request.http as http_request
    import data.policies as policy
    import future.keywords.in

    allow = status {
        not check_if_consumer_is_skipped
        policy[identified_action]
        status := {
           "allowed": true,
           "headers": {"x-request-allowed": "yes"},
           "body": "OPA Checks Passed",
           "http_status": 200
        }
    }

    urls[keys] { policy.urls_to_action_mapping[keys]}

    regex_urls := [url | url := regex.find_n(urls[_], http_request.path, 1)[0]]
    matching_urls := [url | some i; startswith(http_request.path, regex_urls[i]); url := regex_urls[i]]
    identified_url := max(matching_urls)
    identified_action := policy.urls_to_action_mapping[identified_url]

    # Desktop app is not sending x-authenticated-for header due to which managed user flow is breaking
    # This is a temporary fix till the desktop app issue is fixed
    skipped_consumers := ["portal", "desktop"]
    x_consumer_username := http_request.headers["x-consumer-username"]
    check_if_consumer_is_skipped {
       x_consumer_username in skipped_consumers
    }

    allow = status {
       not check_if_consumer_is_skipped
       policy[identified_action]
       status := {
          "allowed": true,
          "headers": {"x-request-allowed": "yes"},
          "body": "OPA Checks Passed",
          "http_status": 200
       }
    }

    allow = status {
       not identified_action
       status := {
          "allowed": true,
          "headers": {"x-request-allowed": "yes"},
          "body": "OPA Checks Skipped",
          "http_status": 200
       }
    }

    # Desktop app is not sending x-authenticated-for header due to which managed user flow is breaking
    # This is a temporary fix till the desktop app issue is fixed
    allow = status {
       check_if_consumer_is_skipped
       status := {
          "allowed": true,
          "headers": {"x-request-allowed": "yes"},
          "body": "OPA Checks Skipped",
          "http_status": 200
       }
    }
  policies.rego: |-
    package policies

    import data.common as super
    import future.keywords.in
    import input.attributes.request.http as http_request

    x_channel_id := http_request.headers["x-channel-id"]
    x_authenticated_userid := http_request.headers["x-authenticated-userid"]
    x_authenticated_user_token := http_request.headers["x-authenticated-user-token"]

    urls_to_action_mapping := {
      "/request/read": "getDataExhaustRequest",
      "/request/list": "listDataExhaustRequest",
      "/request/submit": "submitDataExhaustRequest"
    }

    getDataExhaustRequest {
      acls := ["getDataExhaustRequest"]
      roles := ["ORG_ADMIN", "REPORT_ADMIN", "CONTENT_CREATOR", "COURSE_MENTOR", "PROGRAM_MANAGER", "PROGRAM_DESIGNER"]
      super.acls_check(acls)
      super.role_check(roles)
      x_channel_id
      x_authenticated_userid == super.userid
    }

    getDataExhaustRequest {
      not x_authenticated_user_token
      not x_authenticated_userid
    }

    listDataExhaustRequest {
      acls := ["listDataExhaustRequest"]
      roles := ["ORG_ADMIN", "REPORT_ADMIN", "CONTENT_CREATOR", "COURSE_MENTOR", "PROGRAM_MANAGER", "PROGRAM_DESIGNER"]
      super.acls_check(acls)
      super.role_check(roles)
      x_channel_id
      x_authenticated_userid == super.userid
    }

    listDataExhaustRequest {
      not x_authenticated_user_token
      not x_authenticated_userid
    }

    submitDataExhaustRequest {
      acls := ["submitDataExhaustRequest"]
      roles := ["ORG_ADMIN", "REPORT_ADMIN", "CONTENT_CREATOR", "COURSE_MENTOR"]
      super.acls_check(acls)
      super.role_check(roles)
      input.parsed_body.request.dataset in ["progress-exhaust", "response-exhaust", "userinfo-exhaust"]
      x_channel_id
      x_authenticated_userid == super.userid
    }

    submitDataExhaustRequest {
      acls := ["submitDataExhaustRequest"]
      roles :=["PROGRAM_MANAGER", "PROGRAM_DESIGNER"]
      super.acls_check(acls)
      super.role_check(roles)
      input.parsed_body.request.dataset in ["druid-dataset","program-user-exhaust"]
      x_channel_id
      x_authenticated_userid == super.userid
    }

    submitDataExhaustRequest {
      not x_authenticated_user_token
      not x_authenticated_userid
    }
kind: ConfigMap
metadata:
  annotations:
    meta.helm.sh/release-name: obsrvbb
    meta.helm.sh/release-namespace: sunbird
    reloader.stakater.com/auto: "true"
  creationTimestamp: "2025-05-16T06:33:50Z"
  labels:
    app.kubernetes.io/instance: obsrvbb
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: analytics
    app.kubernetes.io/version: "1.0"
    helm.sh/chart: analytics-0.1.0
  name: analytics-opa
  namespace: sunbird
  resourceVersion: "10953308"
  uid: 29b7ba62-521b-479e-9fea-45f4eeebaa95
